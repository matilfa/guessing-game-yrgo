Jag siktar på VG.

1. Kommandot git pull gör samma sak som git fetch plus git merge, det vill säga hämtar dom senaste ändringarna från ett remote repository och uppdaterar ditt lokala repository med dessa ändringar. Kommandot git push skickar ditt lokala git repository till ett remote repository (som exempelvis kan finnas på GitHub, Bitbucket m.fl.).

2. Kommandot git status kan man använda när man vill se vilka pågående ändringar man har gjort sedan senaste commit, eller för att se vad man har stage:at eller ej. Det ger en bra översikt över nuläget på den aktuella branchen. Kommandot git log visar commithistoriken, med information om varje commits hashkod, meddelande, datum m.m. Det används för att se vad som har gjorts när, för att exempelvis kunna ångra ändringar och gå tillbaka till tidigare commits. 

3. En branch är en slags kopia på ett git repository, som då blir fristående från originalet. Ändringar man gör när man befinner sig på en separat branch påverkar inte working directoryt på andra branchar, och har egen commit-historik. Detta används ofta för att kunna utveckla någon specifik feature, utan att samtidigt påverka main-branchen. Om t.ex. en applikation är aktiv och deployad, vill man inte påverka denna fungerande version medan man vidareutvecklar fler features, så då är det helt nödvändigt att man jobbar på en (eller flera) separat branch. Man uppdaterar branchar mot varandra med git merge.

4. Olika sätt att rulla tillbaka till tidigare tillstånd: 
- git revert: Om man skriver git revert <commit>, där <commit> kan vara exempelvis HEAD eller första 7 tecknen i en specifik commits hash, kommer man att ångra denna commit. Det innebär då att alla ändringar som gjordes i den committen återställs. Man inverterar en commit. Denna invertering sparas som en ny commit högst upp i committrädet. Commithistoriken manipuleras inte av git revert, utan man kan se precis vad som har hänt. Man ska också skriva valfritt meddelande (som med en vanlig commit) på sin revert commit. Detta är ett säkert sätt att ångra ändringar, eftersom historiken inte försvinner, så att man alltid kan gå tillbaka (även för att t.ex. ångra en revert). Det är särskilt användbart när man samarbetar med andra, eftersom det kan orsaka mycket förvirring och komplikationer om delar av gemensam historik ändras/försvinner.
	Exempel på git revert: Jag vill ta bort ändringen från den commit som lade till ett anrop till guesser.start() i main. Då kontrollerar jag först med git log --oneline vilken commit jag vill invertera (i mitt fall heter den 0fa2672 (alternativt HEAD~2)). Sedan skriver jag ‘git revert 0fa2672’. Jag sparar det föreslagna revertmeddelandet när nano poppar upp. Nu är kodraden som anropar guesser.start() i  GuessingGame.java borttagen, och detta sparas som en commit högst upp i committrädet. Inga andra filer eller ändringar påverkas, utan det är endast den valda commitens ändringar som görs ogjorda.
- git restore: Detta kommando kan användas bl.a. för att återställa en specifik fil till tillståndet från en tidigare commit. Det tar inte bort någon historik. Det används också ofta ihop med flaggan ‘--staged’, som tar bort en fil från staging arean.
	Exempel på git restore: Jag råkar ändra något i min .gitignore, som jag committar av misstag. Efter hand märker jag att det är något fel, men jag vet inte vad exakt jag ska ändra, så jag vill återställa .gitignorefilen till hur den såg ut när allting fungerade. Jag kollar med git log --oneline och väljer ett ID för en specifik commit där jag vet att .gitignore fungerade. Sedan skriver jag ‘git restore .gitignore --source=02c07cc’. Då återställs filen och detta registrerar git som en ändring i den filen, vilket behöver committas på nytt om jag vill spara detta. 
- git reset: När man använder git reset kan man ångra ändringar, men detta påverkar även commithistoriken. Det som händer när man gör git reset är att HEAD flyttas till vald punkt. Det finns tre varianter av git reset:
	--mixed: Defaultalternativet för git reset. Detta kommando ihop med ID för önskad commit, flyttar HEAD till den comitten, tar bort all historik för commits gjorda ovanför (dvs efter angiven commit), och alla ändringar sedan föregående commit bevaras i mitt working directory, redo att stage:as.
		Exempel: Jag har lagt till en kommentar i GuessingGame.java. Denna ändring committas med meddelandet “Adding comment”. Jag skriver sedan ‘git reset HEAD~1’, eftersom jag dels vill ändra något jag skrev i kommentaren och dels vill ha ett annat commit message. Committen “Adding comment” finns nu inte längre i historiken. Kommentaren i GuessingGame.java finns kvar, men jag kan nu ändra det jag vill ändra, därefter stage:a och committa med ett annat meddelande, t.ex. “Adding comment to GuessingGame.java”.
	--soft: git reset med flaggan --soft är samma som --mixed, förutom att ändringarna man gjort sedan föregående commit ligger kvar i staging areat. Det kan vara användbart om man t.ex. vill dela upp en commit i flera commits, ifall man committat ändringar i flera filer, men vill dela upp det i en commit per fil. I så fall skriver man git reset --soft HEAD~1, och därefter kan man unstage:a valfri fil med git restore --staged <file>, som man sedan kan lägga i en separat commit. Ett annat bra tillfälle att använda git reset --soft är när man råkat skriva fel i sitt commitmeddelande, och vill justera det.
		Exempel: Jag committar med meddelandet “Addin gitignore”. Jag ser att jag skrivit fel, så jag skriver ‘git reset --soft HEAD~1’ och kör sedan direkt ‘git commit -m “Adding gitignore”’. 
	--hard: Att använda git reset --hard kan vara riskfyllt, eftersom detta kommando permanent tar bort både commithistoriken och påverkar fysiska filer i mitt working directory. Om jag i ovan exempel istället för --mixed hade valt att skriva git reset --hard HEAD~1, hade HEAD flyttats ner till förra committen, så att man inte längre kan se committen “Adding comment”, och den kommentar jag skrivit i GuessingGame.java tas också bort, så att filen återställs till tillståndet från föregående commit. Detta kommando ska man vara försiktig med, och bara använda när man är helt säker på att man vill ta bort allt sedan en viss commit, om man t.ex. har gjort något på prov, som man sen vill ta bort. Eller om man vill ta bort alla sina pågående ocomittade ändringar kan man skriva git reset --hard HEAD. 
		Exempel: Jag har experimenterat och testat massa kod i ett projekt för att se hur saker fungerar, men vill nu återställa allt och gå tillbaka till originalversionen (jag har inte committat några av mina ändringar, men jag har ändrat i flera filer). Då skriver jag ‘git reset --hard HEAD’.

Jag har gjort mina exempel på rollbacks i en separat branch (“rollback-example”) som ligger på min github. Där syns git revert och git restore.

Extrafråga, git rebase:

Vanligtvis när man ska utveckla en specifik feature, så gör man detta på en separat branch, som är till för just den featuren. När då samtidigt andra utvecklare lägger till fler nya funktionaliteter till main så behöver man hålla sin egen branch uppdaterad mot main under tiden som man jobbar på sin feature. Om man ständigt gör git pull (dvs fetch + merge) blir det lätt rörigt i commithistoriken på sin branch. 

Exempel: 
Jag och några fler personer håller på att utveckla en webbapplikation, med stöd för skapande av användare, inloggning, chatt/forum m.m. Jag har just nu i uppgift att utveckla en funktion för att man ska kunna kommentera användares foruminlägg. Detta gör jag på branchen ‘add-commenting’. Jag jobbar på och committar ändringar regelbundet. Om jag varje gång jag vill hålla mig uppdaterad mot main kör git pull så blir det snabbt rörigt i historiken, eftersom main’s commithistorik bakas in i min branchhistorik när jag kör git log. Det blir även en mergecommit högst upp i historiken varje gång. Om jag istället för git pull gör en git rebase, blir det som om jag “klipper ut” alla mina commits som jag gjort på min branch, sen uppdaterar historiken med main’s commits, och därefter “klistrar in” mina commits igen, högst upp i historiken. Då blir det en linjär commithistorik, där jag håller mina branchcommits samlade för sig. Det blir ofta tydligare att göra på detta vis när man jobbar på en feature-branch, särskilt inför en pull request till main, som då kan se tydligt vad branchen har gjort. Så när jag är klar med min nya feature skriver jag ‘git rebase origin/main’ (och löser eventuella konflikter, sedan fortsätter rebasen med ‘git rebase --continue’), för att få en prydlig och linjär historik inför en pull request till main. 
 
Däremot om någon mer jobbar på samma branch som jag, kan rebase vara problematiskt, eftersom dom commits som man “klistrar in” högst upp i trädet är tekniskt sett nya commits, med nya hashnummer (men med samma meddelanden). Så om jag har gjort en rebase mot main på min branch, och någon annan arbetar lokalt med den branchen (som dom har hämtat före att jag pushat min rebase:ade branch till remote-branchen), så kommer inte längre historiken stämma överens när hen försöker pusha sitt arbete till remote-branchen. Så om man ska samarbeta på en och samma branch (remote) är det viktigt att man kommunicerar mellan sig, för att kunna synkronisera sitt arbete. 

